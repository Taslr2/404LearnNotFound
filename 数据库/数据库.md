# 数据库

[TOC]

## 一、引言

### 1.1 数据库发展概述

### 1.2 数据库基本概念

数据是数据库**存储的基本对象**

数据的定义:**描述事物的符号记录**，`数据和语义是不可分的`

- 数据库的定义

  数据库是**长期储存**在计算机内、**有组织的**、**可共享的** **大量数据**的集合。


- 为什么要建立数据库

  收集并抽取出一个应用所需要的大量数据，将其保存以供进一步**加工处理，抽取有用信息，转换为有价值的知识。**

- 数据库的基本特征

  - 数据按一定的**数据模型**组织、描述和储存
  - 较小的**冗余度**
  - 较高的**数据独立性**
  - 易**扩展性**

### 1.3 数据模型与数据建模

#### 1.3.1 数据模型三要素

- 数据结构:描述数据库的组成**对象**以及**对象之间的联系**
- 数据操作:对数据库中各种对象(型)的实例(值)允许执行的**操作的集合，操作符号，操作规则(如优先级)**，数据操作是对模型**动态特性的描述**
- 数据的完整性约束
  - 一组**完整性规则**
  - 完整性规则:给定的数据模型中**数据及其联系所具有的制约和依存规则**
  - 限定符合数据模型的数据库状态以及状态的变化，以**保证数据的正确、有效和相容**

数据模型提供**完整性约束的定义和检查机制**

#### 1.3.2 网状模型

- 网状模型采用**网络结构**来表示各类实体以及实体间的联系
- **网状数据库**系统采用**网状模型**作为数据的组织方式

#### 1.3.3 关系模型

- 关系模型由一组关系组成
- 每个关系的数据结构是一张规范化的二维表



### 1.4 数据库系统的三级模式结构

>型(type):**对某一类数据的结构和属性的说明**
>
>学生(学号，姓名，性别，出生日期，主修专业)
>
>值(value):**型的一个具体赋值**
>
>(20180003，王敏，女，2001-8-1，计算机科学与技术)

#### 1.3.1 模式

- 数据库中**全体数据的逻辑结构和特征的描述**
- 是对数据型的描述，不涉及具体值
- 反映的是数据的结构及其联系
- 模式是相对稳定的

#### 1.3.2 实例

- **模式的一个具体值**
- 反映数据库某一时刻的状态
- 同一个模式可以有很多实例
- 实例随数据库中数据的更新而变动

## 二、关系模型介绍

> 关系：无序集合

### 2.1 关系数据库的结构

在关系模型中：

​	1.关系->表

​	2.元组->表中的行

​	3.属性->表中的列

​	4.关系实例->一个关系的特定实例（即一组特定的行）

​	5.域->某一属性所有可能取到的值的集合

​	6.空值->表示值未知或不存在（应尽量避免）

​		

### 2.2 数据库模式

>数据库模式!=数据库实例

**关系** 的概念对应于程序设计语言中变量的概念， ***关系模式*** 对应于程序设计语言中类型定义的概念



### 2.3 码

如果K足够确定R中的一个元组，则称K是一个超键；当超键K最小时，则称其为候选键键；选出其中一个候选键，即是主键

超键>候选键>主键

外码约束：从r1关系的A属性到r2关系的***主键B*** 的外码约束表明：在任何数据库实例中，r1中对A的任意取值也必须是r2中某个元组对B的取值。则A属性集被称为从r1引用r2的外码，r1称为外码约束的***引用关系***，r2则称为***被引用关系***

引用完整性约束：引用关系中的任意元组在指定属性上出现的取值也必然出现在被引用关系中至少一个元组的指定属性上（***不一定是主码，外码约束是一个特例*** ）



### 2.4 模式图

>一个带有主码和外码约束的数据库模式可以用***模式图*** 表示



### 2.5 关系查询语言

***查询语言*** ：用户用来从数据库中请求获取信息的语言

***命令式查询语言*** ：用户指导系统在数据库上执行**特定的运算序列**以计算出所需结果

***函数式查询语言*** ：可以在数据库中的数据上运行或在其他函数给出的结果上运行；函数没有附带作用，且不更新程序状态

***声明式查询语言*** ：用户只需描述所需信息，而不用给出获取该信息的具体步骤序列或函数调用，所需信息通常使用某种形式的数字逻辑来描述 



### 2.6 关系演算

以**数理逻辑中的谓词演算**为基础的数据库语言

按谓词变元不同，分为:

1. **元组关系演算**
   **以元组变量作为谓词变元的基本对象**
   **元组关系演算语言ALPHA**
2. 域关系演算
   以元组变量的分量(域变量)作为谓词变元的基本对象域关系演算语言QBE

#### 2.6.1 元组关系演算语句ALPHA

主要语句

- 6个语句:**GET(检索操作)**、PUT、HOLD、UPDATE、DELETE、DROP
- 基本格式:操作语句 工作空间名(表达式):操作条件

#### 2.6.2 检索操作（使用元组变量）

元组变量:变化范围是在某一关系内(范围变量range variable)

元组变量的用途

1. 简化关系名:设一个较短名字的元组变量来代替较长的关系名
2. 操作条件中使用**量词时必须用元组变量**

元组变量的定义/说明

- RANGE 关系名 **变量名 **    /用RANGE来说明元组变量/ 
- 一个突系可以设多个元组变量

### 2.7 关系代数

运算的三大要素:运算对象、运算符、运算结果

**关系代数的运算对象是关系，运算结果亦为关系**

![](.\图片\关系运算符.png)

#### 2.7.1选择运算

![](.\图片\选择运算.png)

#### 2.7.2 投影运算

![](.\图片\投影运算.png)

#### 2.7.3 链接运算

![](.\图片\链接运算.png)

#### 2.7.4 除法运算

![](.\图片\除法运算.png)



象集概念及解释：

![](.\图片\象集概念.png)

![](.\图片\象集解释.png) 



除法定义：

![](.\图片\除法定义.png)





## 三、SQL介绍

### 3.1 SQL查询语言概览

 

### 3.2 SQL数据定义

####  		3.2.1 基本数据类型

char(n):：长度固定为n的字符串

varchar(n)：最大长度为n的字符串

int：整数

smallint：小整数

numeric(p,d)：指定精度的定点数，共有p位数字，其中有d位小数

real，double precision：浮点数、双精度浮点数

float(n)：精度至少为n位数字的浮点数



#### 		3.2.2 基本模式定义

通过**create table** 命令来定义SQL关系，下面的命令在数据库中创建了一个department关系：

```sql
create table depatment
(dept_name   varchar(20),
 building    varchar(15),
 budget    	 numeric(12,2),
 primary key(dept_name));
```

create table通用格式：

```sql
create table depatment
(A1  D1,
 A2  D2,
 ... ...,
 An  Dn,
 <完整性约束1>，
 ......，
 <完整性约束n>，);
```

删除数据库：

>drop table r > delete from r

前者直接删除r，后者只删除r中的元组

为已有关系增加属性：**alter table r add A D;**

从关系中去掉属性：**alter table r drop A;**



### 3.3 SQL查询的基本结构

>由 **select,from,where** 三个字句构成

#### 3.3.1单关系查询

e.g."找出所有教师的姓名"

**select** name

**from** instructor;

教师名可以在instructor关系中找到,因此用from,教师的姓名出现在name属性中



如果想去除重复，可以在select后加上distinct,也可以使用all来显式指明不去除重复，缺省选项是保留重复元组

**select** **distinct** name                                    **select** **all** name

**from** instructor;                                            **from** instructor;



select还可以带有+,-,*,/运算符，e.g.

**select** ID,name ,dept_name,salary*1.1

**from** instructor;   

就能得到和原instructor一样的关系，只是salary的值乘了1.1



**where**允许我们制选出那些在from中满足特定谓词的元组，e.g."找出CS系中工资超过70000美元的所有教师的姓名"

**select** name

**from** instructor

**where** dept_name = 'Comp. Sci.' and salary > 70000



**where** 子句中可以使用`and,or,not`，可以包含`>,<,>=,<=,=,<>`,<>为不等于



#### 3.3.2多关系查询

e.g. “找出所有教师的姓名，以及他们所在系的名称和系所在建筑的名称”，在*instructor* 中，我们可以从dept_name属性得到系名，但系所在名称是在*department* 关系的building属性中给出的。所以*instructor* 中的每个元组必须与*department* 关系中的元组匹配，使instructor.dept_name=department.dept_name

​		**select** name,instructor.dept_name,building

​		**from** instructor,department

​		**where** instructor.dept_name=department.dept_name;



### 3.4 附加的基本运算

#### 3.4.1更名运算

**select** T.name,S.course_id

**from** instructors **as** T,teaches **as** S

**where** T.ID=S.ID;

***as*** 既可以出现在**select**子句中，也可以出现在**from**子句中



#### 3.4.2 字符串运算

>正常情况是大小写敏感的，但在MySQL或PostageSQL中使用ilike的时候，是大小写不敏感的

` 数据库可以实现连接字符串（'||'）、提取字串、计算字符串长度、大小写转换(upper(s),lower(s))、去掉字符串后面空格(trim(s))`

在字符串上可以使用**like**运算符来实现模式匹配：

- %：%字符匹配任意子串
- _ : _字符匹配任意一个字符

e.g.

- 'Intro%'匹配以'Intro'打头的任意字符串
- '%Comp%'匹配包含'Comp'子串的任意字符串
- ‘_ _ _’匹配只含三个字符的任意字符串
- '_ _ _%'匹配至少含有三个字符的任意字符串

具体查询e.g.

**select** dept_name

**from** department

**where** building like '%Waston%'



#### 3.4.3 select子句中的属性说明

'*'表示所有的属性

e.g. 

**select** instructor.*

**from** instructor,teaches

**where** instructor.ID=teaches.ID;



#### 3.4.4 排列元组的显示次序

**order by**子句可以让查询结果按顺序显示,缺省情况下按升序，desc表示降序，asc表示升序

e.g."按字母顺序列出物理系的所有教师"

**select** name

**from** instructor

**where** dept_name='Physics'

**order by** name;

e.g."按salary降序，如果一样，则用asc升序"

**select * **

**from** instructor

**order by** salary **desc**,name **asc**;



#### 3.4.5 where子句谓词

**between**表示</<=某个值，>/>=某个值

e.g. 

**select** name

**from** instructor

**where** salary **between** 90000 **and** 100000;



允许解构

e.g.

**select** name,course_id

**from** instructor,teaches

**where** instructor.ID =teaches.ID **and** dept_name='Biology'

等同于

**select** name,course_id

**from** instructor,teaches

**where** （instructor.ID，dept_name）=（teaches.ID,'Biology');



### 3.5 集合运算

>union、intersect、except对应集合的并，交和减

e.g.

(**select** course_id

**from** section

**where** semester = 'Fall' **and** year=2017)

**union**

**(select** course_id

**from** section

**where** semester = 'Spring' **and** year=2018);



### 3.6 空值

空值代表**unknown**，是除true和false之外的第三种逻辑值



### 3.7聚集函数

> **聚集函数**是以值集为输入并返回单个值的函数

SQL提供了五个标准的固有聚集函数：

- 平均值：avg
- 最小值：min
- 最大值：max
- 总和：sum
- 计数：count

**sum**和**avg**的输入必须是数字集，但其他运算符可以作用在非数字数据类型的集合上

#### 3.7.1基本聚集

e.g."找出CS系教师的平均工资"

**select** **avg** (salary)

**from** instructor

**where** dept_name='Comp.Sci'



"找出在2018年春季学期授课的教师总数"

**select** **count** (**distinct** ID)

**from** teaches

**where** semester ='Spring' **and** year=2018;

`由于用了distinct，即使一位老师教了多门课，也只会计算一次`



“用count计算一个关系中元组的数量”

**select** **count** (*)

**from** course;



#### 3.7.2 分组聚焦

e.g."找出每个系的平均工资"

**select** dept_name,**avg** (salary) **as** avg_salary

**from** instructor

**group by** dept_name

> tips:任何没有出现在group by 子句中的属性如果出现在select子句中，他只能作为聚集函数的参数，否则这样的查询就是错误的

e.g.

**select** dept_name,ID,**avg**(salary)

**from** instrcuctor

**group by** dept_name

因为ID没有出现在**group by**中，而且没有被聚焦，所以是错误查询



#### 3.7.3 having子句

用于对分组加限定条件

e.g.

**select** dept_name,**avg**(salary) **as** avg_salary

**from** instructor

**group by** dept_name

**having avg** (salary) >42000;

同时，出现在having子句中但没有被聚集的属性必须出现在**group by** 子句中



#### 3.7.4 对空值和布尔值的聚集

除了**count(*)**之外的聚集函数都忽略其输入集合中的空值



### 3.8 嵌套子查询

#### 3.8.1 集合成员资格

> in测试集合成员资格，not in测试集合成员资格的缺失

e.g."找出在2017年秋季和2018年春季学期都开课的所有课程”

**select ditinct** course_id

**from** section

**where** semester = 'Fall' **and** year=2017 **and**

​		course_id **in**(**select** course_id

​						      **from** section

​							  **where** semester='Spring' **and** year=2018);



**in**和**not in** 也能用于枚举集合，e.g.

**select distinct** name

**from** instructor

**where** name **not in** ('Mozart','Einstein');

>同样支持解构语法



#### 3.8.2 集合比较

> 用>some表示“至少比某一个大"

e.g."找出工资至少比Biology系某位教师的工资要高的所有教师的姓名“

**selsect** name

**from** instructor

**where** salary**>some** (**select** salary

​									**from** instructor

​									**where** dept_name='Biology');



#### 3.8.3 空关系测试

> exists结构在作为参数的子查询非空时返回true值

e.g.e.g."找出在2017年秋季和2018年春季学期都开课的所有课程”(同3.8.1)

**select** course_id

**from** section **as** S

**where** semester = 'Fall' **and** year=2017 **and**

​	**exists**(**select ***

​				**from** section **as** T

​				**where** semester ='Spring' **and** year=2018 **and**

​				S.course_id=T.course_id);



#### 3.8.4重复元组存在性测试

> 如果在作为参数的子查询结果中没有重复的元组，则**unique** 结构返回true



#### 3.8.5 from子句中的子查询

> 任何select-from-where表达式返回的结果都是关系，因而可以被插入到另一个select-from-where中关系可以出现的任何位置



#### 3.8.6 with子句

> **with**子句提供了一种定义临时关系的方式，这个定义只对包含**with**子句的查询有效

e.g.

**with** max_budget (value) **as**

​		(**select max**(budget)

​		**from** department)

**select** budget

**from** department,max_budget

**where** department.budget = max_budget.value;



#### 3.8.7 标量子查询

> SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只返回一个包含单个属性的元组；这样的子查询称为标量子查询



#### 3.8.8 不带from子句的标量

若是因为缺少from子句报错，则可以创建一个特殊的虚拟关系



### 3.9 数据库的修改

#### 3.9.1 删除

**delete from** r

**where** P

其中P代表一个谓词,r代表一个关系.delete从r中找出使P(t)为真的所有元组t,然后把他们从r中删除;where子句可以省略,省略的情况下删除r中所有元组



#### 3.9.2 插入

**insert**是插入一个元组的请求

**insert into** r(...)

​	**values**(D)

r为关系,D为属性值,'...'为属性名,可写可不写,缺省情况下默认为原关系中属性的顺序



#### 3.9.3 更新

**update** r

**set** P

**where** Q

r为关系,P为要对原属性进行的操作,Q为筛选条件,可写可不写



提供**case**结构,e.g.

**update** instructor

**set** salary = **case**

**when** salary<=100000 **then** salary*1.05

**else** salary*1.03

**end**

> **when** pred **then** result结构可以一直叠加,类似if...else



## 四、中级SQL

### 4.1 连接表达式

#### 4.1.1自然连接

（只考虑在两个关系的模式中都出现的那些属性上取值相同的元组对）：from r1 **natural join** r2 **natural join** r3... **natural join** rn

可以使用join...using(A)指定属性名，被连接的两个关系都必须具有指定名称的属性

e.g. **from** (student **natural join** takes) **join** course **using** (course_id)



#### 4.1.2 连接条件

**on** 允许在连接的关系上设置通用的**谓词**

e.g. **from** student **join** takes **on** student.ID = takes.ID



#### 4.1.3 外连接

与连接运算类似，但可以在结果中创建包含空的元组，共有三种形式

- **左外连接**：只保留出现在**左外连接**运算之前的关系中的元组
- **右外连接**：只保留出现在**右外连接**运算之后的关系中的元组
- **全外连接**：保留出现在两个关系中的元组

左外连接e.g. **from** student **natural left outer join** takes;，会保留学生ID70557的信息，但是只出现在takes中的属性值为null

右外连接e.g.**from** takes **natural right outer join** student;

全外连接是左外连接和右外连接的并运算e.g.**from** takes **natural full outer join** student



#### 4.1.4连接类型和条件

缺省的是内连接：**(inner) join**

外连接需显式指定：**outer join**



### 4.2 视图

#### 4.2.1视图定义

通过**create view**命令来定义视图，格式为：

**create view** v(D) **as** <查询表达式>;

视图与**with**的不同之处在于：视图一旦被创建，在被显式删除之前就一直是可用的，由**with**定义的命名子查询对于定义它的查询来说只是本地可用的



#### 4.2.2 在SQL查询中使用视图

一旦我们定义了一个视图，就可以用视图名来指代该视图所生成的虚拟关系



#### 4.2.3 物化视图

> 物化视图：如果用于定义视图的实际关系发生改变，则视图也跟着修改以保持最新

**物化视图维护/视图维护**：保持物化视图一直在最新状态的过程



#### 4.2.4 视图更新

如果满足以下条件，则称SQL视图是**可更新的**：

- **from**子句中只有一个数据库关系
- **select**子句中只包含关系的属性名，并不包含任何表达式、聚集或distinct声明
- 没有出现在**select**子句中的任何属性都可以取**null**值；也就是说这些属性没有**非空**约束，也不构成主码的一部分
- 查询中不含有**group by**或**having**子句

在这些限制下，允许执行**update**,**insert**,和**delete**

可以在视图末尾包含**with check option**子句的方式来定义视图；这样如果向视图中插入一条不满足视图的where子句条件的元组，则数据库系统就会拒绝该插入操作



### 4.3 事务

当一条SQl语句被执行时，就隐式地开始了一个事务，下列SQL语句之一会结束该事务：

- **commit work**提交当前事务；它使事务执行的更新在数据库中成为永久性的。在事务被提交后，一个新的事务会自动开始

- **rollback work**回滚当前事务；也就是说它会撤销事务中SQL语句执行的所有更新，因此，数据库状态被恢复到它执行该事务的第一条语句之前的状态

  关键字**work**在两条语句中都是可选的



### 4.4 完整性约束

> 完整性约束保证授权用户对数据库所做的修改不会导致数据一致性的丢失

一般来说，一个完整性约束可以输关于数据库的任意谓词



#### 4.4.1单个关系上的约束

create table中，允许的完整性约束包括：

- **not null**
- **unique**
- **check**（<谓词>）



#### 4.4.2 非空约束

如果希望禁止空值，可以在创建属性时这么声明：
name **varchar(20) not null**

budget **numeric(12,2) not null**

**非空**约束禁止对该属性插入空值，并且它是**域约束**



#### 4.4.3唯一性约束

**unique**(A1,A2,...,An)

**唯一性**声明指出属性A1,A2...,An形成了一个超码；也就是说在关系中没有两个元组能在所有列出的属性上取值相同；然而声明了唯一性的属性允许为null，除非它们已被显式地声明为非空



#### 4.4.4 check子句

**check(P)**指定一个谓词P,关系中每个元组都必须满足谓词P

e.g. **check**(budget > 0)子句保证budget上的取值是非负的



#### 4.4.5 引用完整性

通过外码子句，将外码指定为SQL的创建表语句的一部分

e.g.**foreign key **(dept_name) **references** depatment表示对于每个课程元组，元组中指定的系名必须在department关系中存在



#### 4.4.6 给约束赋名

e.g. salary **numeric**(8,2),**constraint** minsalary **check** (salary > 29000),

这样如果以后不再需要这个约束，就可以写为：

**alter table** instructor **drop constraint** minsalary



#### 4.4.7 事务中对完整性约束的违反

